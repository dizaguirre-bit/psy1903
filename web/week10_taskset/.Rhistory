# Generate dataset reproducibly
set.seed(1903)
subject_id <- 1:40
rt <- round(rnorm(40, mean = 520, sd = 120))
rt[sample(1:40, 2)] <- NA
congruent <- sample(c(TRUE, FALSE), 40, replace = TRUE)
condition <- sample(c("control", "incongruent"), 40, replace = TRUE)
experiment_data <- data.frame(subject_id, rt, congruent, condition)
# Save for reuse in later tasks
saveRDS(experiment_data, file = "data/raw/experiment_data.rds")
---
title: "Week 10 Task Set"
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Take a quick look at the first few rows
head(experiment_data)
## Check the structure of the dataset
str(experiment_data)
rm (list = ls())
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Take a quick look at the first few rows
head(experiment_data)
## Check the structure of the dataset
str(experiment_data)
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
experiment_data$rt_category <- function() {
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
} else{
ifelse(
is.na(experiment_data$rt), "Unknown",
ifelse(experiment_data$rt < 500, "Fast", "Slow")
)
}
}
View(experiment_data)
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
experiment_data$rt_category <- ifelse(
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
},
ifelse(
is.na(experiment_data$rt), "Unknown",
ifelse(experiment_data$rt < 500, "Fast", "Slow")
)
)
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
experiment_data$rt_category <- function (rt, threshold = 500) {
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
} else { ifelse(is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow"))
}
}
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
experiment_data$rt_category <- function (rt, threshold = 500) {
ifelse(
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
}, ifelse(is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow")
)
)
}
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
experiment_data$rt_category <- function (rt, threshold = 500) {
if (!is.numeric(rt)) {
stop("Error: 'rt' must be numeric.")
}
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
}
ifelse(
is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow")
)
}
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA
classify_rt <- function (rt, threshold = 500) {
if (!is.numeric(rt)) {
stop("Error: 'rt' must be numeric.")
}
if (!is.numeric(threshold) || length(threshold) != 1) {
stop("Error: 'threshold' must be a single numeric value.")
}
ifelse(
is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow")
)
}
experiment_data$rt_category <- classify_rt(experiment_data$rt, 500)
experiment_data$age <- NA
for (i in 1:nrow(experiment_data)) {
experiment_data$age <- getRandomNumber(18, 65, 1)
}
## Generate one or more random numbers between min and max (defaults: one number between 1–10)
getRandomNumber <- function(min = 1, max = 10, number = 1) {
sample(min:max, number)
}
for (i in 1:nrow(experiment_data)) {
experiment_data$age <- getRandomNumber(18, 65, 1)
}
for (i in 1:nrow(experiment_data)) {
experiment_data[i, "age"] <- getRandomNumber(18, 65, 1)
}
for (i in 1:nrow(experiment_data)) {
experiment_data[i, "age"] <- getRandomNumber(18, 65, 1)
}
head(experiment_data)
apply(experiment_data$age, sample(18:65, nrow(experiment_data)))
apply(experiment_data$age, 2, sample(18:65, nrow(experiment_data)))
?sample
apply(experiment_data$age, 2, sample(18:65, replace = TRUE, nrow(experiment_data)))
apply(experiment_data[, "age"], 2, sample)
experiment_data$age <- sample(18:65, replace = TRUE, nrow(experiment_data)))
experiment_data$age <- sample(18:65, replace = TRUE, nrow(experiment_data))
experiment_data$age <- sample(18:65, replace = TRUE, nrow(experiment_data))
head(experiment_data)
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
if (is.na(experiment_data[i, "rt"])) {
experiment_data[i, "rt_category_loop"] <- "Unknown"
} else if (experiment_data[i, "rt"] < 500) {
experiment_data[i, "rt_category_loop"] <- "Fast"
} else {
experiment_data[i, "rt_category_loop"] <- "Slow"
}
}
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
if (is.na(experiment_data[i, "rt"])) {
experiment_data[i, "rt_category_loop"] <- "Unknown"
} else if (experiment_data[i, "rt"] < 500) {
experiment_data[i, "rt_category_loop"] <- "Fast"
} else {
experiment_data[i, "rt_category_loop"] <- "Slow"
}
}
experiment_data$rt_category_loop <- NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
if (is.na(experiment_data[i, "rt"])) {
experiment_data[i, "rt_category_loop"] <- "Unknown"
} else if (experiment_data[i, "rt"] < 500) {
experiment_data[i, "rt_category_loop"] <- "Fast"
} else {
experiment_data[i, "rt_category_loop"] <- "Slow"
}
}
experiment_data$rt_category_loop <- NA
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
experiment_data[i, "rt_category_loop"] <- classify_rt(experiment_data$rt, 500)
}
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
experiment_data[i, "rt_category_loop"] <- classify_rt(experiment_data[i, "rt"], 500)
}
experiment_data$rt_category_loop <- NA
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
experiment_data$rt_category_loop <- for (i in 1:nrow(experiment_data)) {
experiment_data$rt_category_loop <- classify_rt(experiment_data[i, "rt"], 500)
}
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
for (i in 1:nrow(experiment_data)) {
experiment_data[i, "rt_category_loop"] <- classify_rt(experiment_data[i, "rt"], 500)
}
experiment_data$rt_category_vec <- NA
experiment_data$rt_category_vec <- NA
experiment_data$rt_category_vec <- classify_rt(experiment_data$rt, threshold = 500)
table(loop = experiment_data$rt_category_loop,
vec  = experiment_data$rt_category_vec,
useNA = "ifany")
?table
## Create Buggy Function
threshold <- 500
flag_fast <- function(rt_vector) {
rt_vector < threshold
}
flag_fast("rt")
flag_fast(experiment_data$rt)
rm(threshold)
flag_fast(experiment_data$rt)
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
flag_fast(experiment_data$rt)
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
rm(threshold)
flag_fast(experiment_data$rt)
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
function(x) mean(x, na.rm = TRUE)) ## define anonymous function to be used in tapply so we can apply mean AND na.rm at the same time
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
# How many NAs overall?
sum(is.na(experiment_data$rt))
# How many NAs by condition?
tapply(is.na(experiment_data$rt), experiment_data$condition, sum)
# Optional: quick sanity checks
summary(experiment_data$rt)
with(experiment_data, table(condition, is.na(rt)))
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
function(x) mean(x, na.rm = TRUE)) ## define anonymous function to be used in tapply so we can apply mean AND na.rm at the same time
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
write.csv(experiment_data, "experiment_data.csv")
saveRDS(experiment_data, "experiment_data.rds")
write.csv(experiment_data, "experiment_data.csv", row.names = FALSE)
saveRDS(experiment_data, "experiment_data.rds")
save(my_experiment, subject_means, file = "data/cleaned/objects.RData")
save(experiment_data, subject_means, file = "data/cleaned/objects.RData")
save(experiment_data, subject_means, file = "reports/objects.RData")
save(experiment_data, subject_means, file = "objects.RData")
rm(list = ls())
load("data/cleaned/important_objects.RData")
load("objects.RData")
subject_means <- tapply(experiment_data$rt, ## reusing this buggy code
experiment_data$condition,
mean)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
## fixed code from ChatGPT
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean,
na.rm = TRUE)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
subject_means
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
rm(threshold)
flag_fast(experiment_data$rt)
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Take a quick look at the first few rows
head(experiment_data)
## Check the structure of the dataset
str(experiment_data)
## Generate one or more random numbers between min and max (defaults: one number between 1–10)
getRandomNumber <- function(min = 1, max = 10, number = 1) {
sample(min:max, number)
}
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA ## create new column for rt category
classify_rt <- function (rt, threshold = 500) {
if (!is.numeric(rt)) { ## input validation for making sure rt is numeric
stop("Error: 'rt' must be numeric.")
}
if (!is.numeric(threshold) || length(threshold) != 1) { ## input validation for making sure threshold is single numeric value
stop("Error: 'threshold' must be a single numeric value.")
}
ifelse( ## conditional code for categorizing reaction times, vectorized for efficiency
is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow")
)
}
experiment_data$rt_category <- classify_rt(experiment_data$rt, 500)
experiment_data$age <- NA ## create new column called age and populate w/ NA
for (i in 1:nrow(experiment_data)) {
experiment_data[i, "age"] <- getRandomNumber(18, 65, 1) ## sample a random number for as many rows as in the "age" column
}
head(experiment_data)
experiment_data$age <- sample(18:65, replace = TRUE, nrow(experiment_data)) ## sample as many rows as are in the df
head(experiment_data)
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
for (i in 1:nrow(experiment_data)) { ## fill empty column row by row using classify_rt
experiment_data[i, "rt_category_loop"] <- classify_rt(experiment_data[i, "rt"], 500) ## classify using individual value of every row of rt
}
experiment_data$rt_category_vec <- NA ## create empty column and populate w/ NA
experiment_data$rt_category_vec <- classify_rt(experiment_data$rt, threshold = 500) ## fill using classify_rt
table(loop = experiment_data$rt_category_loop,
vec  = experiment_data$rt_category_vec,
useNA = "ifany")
## Create Buggy Function
threshold <- 500
flag_fast <- function(rt_vector) {
rt_vector < threshold
}
flag_fast(experiment_data$rt)
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
# rm(threshold)
flag_fast(experiment_data$rt)
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
# How many NAs overall?
sum(is.na(experiment_data$rt))
# How many NAs by condition?
tapply(is.na(experiment_data$rt), experiment_data$condition, sum)
# Optional: quick sanity checks
summary(experiment_data$rt)
with(experiment_data, table(condition, is.na(rt)))
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
function(x) mean(x, na.rm = TRUE)) ## define anonymous function to be used in tapply so we can apply mean AND na.rm at the same time
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
## fixed code from ChatGPT
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean,
na.rm = TRUE)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
write.csv(experiment_data, "../data/cleaned/experiment_data.csv", row.names = FALSE) ## save as .csv
saveRDS(experiment_data, "../data/cleaned/experiment_data.rds") ## save as .rds
save(experiment_data, subject_means, file = "../data/raw/objects.RData") ## save as
rm(list = ls())
load("objects.RData")
## Load the saved dataset
experiment_data <- readRDS("../data/raw/experiment_data.rds")
## Take a quick look at the first few rows
head(experiment_data)
## Check the structure of the dataset
str(experiment_data)
## Generate one or more random numbers between min and max (defaults: one number between 1–10)
getRandomNumber <- function(min = 1, max = 10, number = 1) {
sample(min:max, number)
}
## Classify reaction times into "Fast", "Slow", or "Unknown" (default threshold = 500ms)
experiment_data$rt_category <- NA ## create new column for rt category
classify_rt <- function (rt, threshold = 500) {
if (!is.numeric(rt)) { ## input validation for making sure rt is numeric
stop("Error: 'rt' must be numeric.")
}
if (!is.numeric(threshold) || length(threshold) != 1) { ## input validation for making sure threshold is single numeric value
stop("Error: 'threshold' must be a single numeric value.")
}
ifelse( ## conditional code for categorizing reaction times, vectorized for efficiency
is.na(rt), "Unknown",
ifelse (rt < threshold, "Fast", "Slow")
)
}
experiment_data$rt_category <- classify_rt(experiment_data$rt, 500)
experiment_data$age <- NA ## create new column called age and populate w/ NA
for (i in 1:nrow(experiment_data)) {
experiment_data[i, "age"] <- getRandomNumber(18, 65, 1) ## sample a random number for as many rows as in the "age" column
}
head(experiment_data)
experiment_data$age <- sample(18:65, replace = TRUE, nrow(experiment_data)) ## sample as many rows as are in the df
head(experiment_data)
experiment_data$rt_category_loop <- NA ## create an empty column and populate with NA
for (i in 1:nrow(experiment_data)) { ## fill empty column row by row using classify_rt
experiment_data[i, "rt_category_loop"] <- classify_rt(experiment_data[i, "rt"], 500) ## classify using individual value of every row of rt
}
experiment_data$rt_category_vec <- NA ## create empty column and populate w/ NA
experiment_data$rt_category_vec <- classify_rt(experiment_data$rt, threshold = 500) ## fill using classify_rt
table(loop = experiment_data$rt_category_loop,
vec  = experiment_data$rt_category_vec,
useNA = "ifany")
## Create Buggy Function
threshold <- 500
flag_fast <- function(rt_vector) {
rt_vector < threshold
}
flag_fast(experiment_data$rt)
flag_fast <- function(rt_vector, threshold = 500) {
rt_vector < threshold
}
# rm(threshold)
flag_fast(experiment_data$rt)
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
# How many NAs overall?
sum(is.na(experiment_data$rt))
# How many NAs by condition?
tapply(is.na(experiment_data$rt), experiment_data$condition, sum)
# Optional: quick sanity checks
summary(experiment_data$rt)
with(experiment_data, table(condition, is.na(rt)))
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
function(x) mean(x, na.rm = TRUE)) ## define anonymous function to be used in tapply so we can apply mean AND na.rm at the same time
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
## fixed code from ChatGPT
subject_means <- tapply(experiment_data$rt,
experiment_data$condition,
mean,
na.rm = TRUE)
print(paste("Mean for control:", subject_means["control"]))
print(paste("Mean for incongruent:", subject_means["incongruent"]))
write.csv(experiment_data, "../data/cleaned/experiment_data.csv", row.names = FALSE) ## save as .csv
saveRDS(experiment_data, "../data/cleaned/experiment_data.rds") ## save as .rds
save(experiment_data, subject_means, file = "../data/raw/objects.RData") ## save as
rm(list = ls())
load("../data/cleaned/objects.RData")
